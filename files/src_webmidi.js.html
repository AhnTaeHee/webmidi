<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/webmidi.js - WebMidi</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo.png" title="WebMidi" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 1.0.0-beta.2</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/WebMidi.html">WebMidi</a></li>
                            </ul>
                
                
                            <ul id="api-modules" class="apis modules">
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: src/webmidi.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
(function(scope) {

  &quot;use strict&quot;;

  /**
   * The &#x60;WebMidi&#x60; object makes it easier to work with the Web MIDI API. Basically, it
   * simplifies two things: sending and receiving MIDI messages.
   *
   * To send MIDI messages, you simply need to call the desired method (&#x60;playNote()&#x60;,
   * &#x60;sendPitchBend()&#x60;, &#x60;stopNote()&#x60;, etc.) with the appropriate parameters and all the
   * native MIDI communication will be handled for you. The only additional thing that
   * needs to be done is enable &#x60;WebMidi&#x60;. Here is an example:
   *
   *      WebMidi.enable(function() {
   *        WebMidi.playNote(2, &quot;C3&quot;);
   *      });
   *
   * The code above, calls the &#x60;WebMidi.enable()&#x60; method. Upon success, this method
   * executes the callback function specified as a parameter. In this case, the callback
   * calls the &#x60;playnote()&#x60; function to play a 3rd octave C (note number 60) on channel 2.
   *
   * Receiving messages is just as easy. You simply have to set a callback function to be
   * triggered when a specific MIDI message is received. For example, to listen for pitch
   * bend events on any input MIDI channels:
   *
   *      WebMidi.addListener(&#x27;pitchbend&#x27;, function(e) {
   *        console.log(&quot;Pitch value: &quot; + e.value);
   *      });
   *
   * As you can see, this library makes it much easier to use the Web MIDI API. No need to
   * manually craft or decode binary MIDI messages anymore!
   *
   * @class WebMidi
   * @static
   *
   * @todo  Add removeAllEventListeners(), on() and once() functions
   * @todo  Add a &#x27;filter&#x27; parameter to addListener. This would allow to listen for a
   *        specific controller on a controlchange event or a specific note on a event
   *        message.
   *
   * @todo  Add more examples in method documentation (playNote namely).
   * @todo  Add specific events for channel mode messages ?
   * @todo  Yuidoc does not allow multiple exceptions (@throws) for a single method ?!
   * @todo  Should the sendsysex method allow Uint8Array param ?
   * @todo  Define textual versions of channel mode messages
   */
  function WebMidi() {

    Object.defineProperties(this, {

      /**
       * [read-only] Indicates whether the browser supports the Web MIDI API or not.
       *
       * @property supported
       * @type Boolean
       * @static
       */
      supported: {
        enumerable: true,
        get: function() {
          return &quot;requestMIDIAccess&quot; in navigator;
        }
      },

      /**
       * [read-only] Indicates whether the interface to the host&#x27;s MIDI subsystem is
       * currently active.
       *
       * @property connected
       * @type Boolean
       * @static
       */
      connected: {
        enumerable: true,
        get: function() {
          return this.interface !== undefined;
        }
      },

      /**
       * [read-only] An array of all currently available MIDI input devices.
       *
       * @property inputs
       * @type {MIDIInput[]}
       * @static
       */
      inputs: {
        enumerable: true,
        get: function() {
          var inputs = [];
          if (this.connected) {
            var ins = this.interface.inputs.values();
            for (var input = ins.next(); input &amp;&amp; !input.done; input = ins.next()) {
              inputs.push(input.value);
            }
          }
          return inputs;
        }
      },

      /**
       * [read-only] An array of all currently available MIDI output devices.
       *
       * @property outputs
       * @type {MIDIOutput[]}
       * @static
       */
      outputs: {
        enumerable: true,
        get: function() {
          var outputs = [];
          if (this.connected) {
            var outs = this.interface.outputs.values();
            for (var input = outs.next(); input &amp;&amp; !input.done; input = outs.next()) {
              outputs.push(input.value);
            }
          }
          return outputs;
        }
      },

      /**
       * [read-only] Current MIDI performance time in milliseconds. This can be used to
       * queue events in the future.
       *
       * @property time
       * @type DOMHighResTimeStamp
       * @static
       */
      time: {
        enumerable: true,
        get: function() {
          return window.performance.now();
        }
      }

    });

    _initializeUserHandlers();

  }

  //////////////////////////////// PRIVATE PROPERTIES ////////////////////////////////////

  // User-defined handlers list
  var _userHandlers = { &quot;channel&quot;: {}, &quot;system&quot;: {} };

  // List of valid channel MIDI messages and matching value
  var _channelMessages = {
    &quot;noteoff&quot;: 0x8,           // 8
    &quot;noteon&quot;: 0x9,            // 9
    &quot;keyaftertouch&quot;: 0xA,     // 10
    &quot;controlchange&quot;: 0xB,     // 11
    &quot;channelmode&quot;: 0xB,       // 11
    &quot;programchange&quot;: 0xC,     // 12
    &quot;channelaftertouch&quot;: 0xD, // 13
    &quot;pitchbend&quot;: 0xE          // 14
  };

  // List of valid system MIDI messages and matching value (249 and 253 are actually
  // dispatched by the Web MIDI API but I do not know what they are for and they are not
  // part of the online MIDI 1.0 spec. (http://www.midi.org/techspecs/midimessages.php)
  var _systemMessages = {
    &quot;sysex&quot;: 0xF0,            // 240
    &quot;timecode&quot;: 0xF1,         // 241
    &quot;songposition&quot;: 0xF2,     // 242
    &quot;songselect&quot;: 0xF3,       // 243
    &quot;tuningrequest&quot;: 0xF6,    // 246
    &quot;sysexend&quot;: 0xF7,         // 247 (never actually received - simply ends a sysex)
    &quot;clock&quot;: 0xF8,            // 248
    &quot;start&quot;: 0xFA,            // 250
    &quot;continue&quot;: 0xFB,         // 251
    &quot;stop&quot;: 0xFC,             // 252
    &quot;activesensing&quot;: 0xFE,    // 254
    &quot;reset&quot;: 0xFF,            // 255
    &quot;unknownsystemmessage&quot;: -1
  };

  var _notes = [&quot;C&quot;, &quot;C#&quot;, &quot;D&quot;, &quot;D#&quot;, &quot;E&quot;, &quot;F&quot;, &quot;F#&quot;, &quot;G&quot;, &quot;G#&quot;, &quot;A&quot;, &quot;A#&quot;, &quot;B&quot;];

  /////////////////////////////////// PRIVATE METHODS ////////////////////////////////////

  /**
   * @method _initializeUserHandlers
   * @private
   */
  function _initializeUserHandlers() {

    _userHandlers.system.statechange = [];

    for (var prop1 in _channelMessages) {
      if (_channelMessages.hasOwnProperty(prop1)) {
        _userHandlers.channel[prop1] = {};
      }
    }

    for (var prop2 in _systemMessages) {
      if (_systemMessages.hasOwnProperty(prop2)) {
        _userHandlers.system[prop2] = [];
      }
    }

  }

  /**
   * @method _onInterfaceStateChange
   * @private
   */
  function _onInterfaceStateChange(e) {

    /**
     * Event emitted when the interface&#x27;s state changes. Typically, this happens when a
     * MIDI device is being plugged or unplugged. This event cannot be listened on a
     * single specific MIDI device, it is intended to be interface-wide. If a device is
     * specified, it will be silently ignored.
     *
     * @event statechange
     *
     * @param {Object} event
     *
     * @todo complete documentation
     */
    _userHandlers.system.statechange.forEach(function(handler){
      handler(e);
    });

  }

  /**
   * @method _parseChannelEvent
   * @private
   */
  function _parseChannelEvent(e) {

    var command = e.data[0] &gt;&gt; 4;
    var channel = (e.data[0] &amp; 0xf) + 1;
    var data1, data2;

    if (e.data.length &gt; 1) {
      data1 = e.data[1];
      data2 = e.data.length &gt; 2 ? e.data[2] : undefined;
    }

    // Returned event
    var event = {
      &quot;device&quot;: e.currentTarget,
      &quot;data&quot;: e.data,
      &quot;receivedTime&quot;: e.receivedTime,
      &quot;timeStamp&quot;: e.timeStamp,
      &quot;channel&quot;: channel
    };

    if (
        command === _channelMessages.noteoff ||
        (command === _channelMessages.noteon &amp;&amp; data2 === 0)
    ) {

      /**
       * Event emitted when a note off MIDI message has been received on a specific device and
       * channel.
       *
       * @event noteoff
       *
       * @param {Object} event
       * @param {MIDIInput} event.device    The MIDI input device that triggered the event.
       * @param {Uint8Array} event.data     The raw MIDI message as an array of 8 bit values.
       * @param {Number} event.receivedTime The time when the event occurred (in milliseconds since
       *                                    start).
       * @param {uint} event.timeStamp      The timestamp when the event occurred (in milliseconds
       *                                    since the epoch).
       * @param {uint} event.channel        The channel where the event occurred (between 1 and 16).
       * @param {String} event.type         The type of event that occurred.
       * @param {Object} event.note
       * @param {uint} event.note.number    The MIDI note number.
       * @param {String} event.note.name    The usual note name (C, C#, D, D#, etc.).
       * @param {uint} event.note.octave    The octave (between -2 and 8).
       * @param {Number} event.velocity     The release velocity (between 0 and 1).
       */
      event.type = &#x27;noteoff&#x27;;
      event.note = {
        &quot;number&quot;: data1,
        &quot;name&quot;: _notes[data1 % 12],
        &quot;octave&quot;: Math.floor(data1 / 12 - 1) - 3
      };
      event.velocity = data2 / 127;

    } else if (command === _channelMessages.noteon) {

      /**
       * Event emitted when a note on MIDI message has been received on a specific device and
       * channel.
       *
       * @event noteon
       *
       * @param {Object} event
       * @param {MIDIInput} event.device    The MIDI input device that triggered the event.
       * @param {Uint8Array} event.data     The raw MIDI message as an array of 8 bit
       *                                    values.
       * @param {Number} event.receivedTime The time when the event occurred (in milliseconds since
       *                                    start).
       * @param {uint} event.timeStamp      The timestamp when the event occurred (in milliseconds
       *                                    since the epoch).
       * @param {uint} event.channel        The channel where the event occurred (between 1 and 16).
       * @param {String} event.type         The type of event that occurred.
       * @param {Object} event.note
       * @param {uint} event.note.number    The MIDI note number.
       * @param {String} event.note.name    The usual note name (C, C#, D, D#, etc.).
       * @param {uint} event.note.octave    The octave (between -2 and 8).
       * @param {Number} event.velocity     The attack velocity (between 0 and 1).
       */
      event.type = &#x27;noteon&#x27;;
      event.note = {
        &quot;number&quot;: data1,
        &quot;name&quot;: _notes[data1 % 12],
        &quot;octave&quot;: Math.floor(data1 / 12 - 1) - 3
      };
      event.velocity = data2 / 127;

    } else if (command === _channelMessages.keyaftertouch) {

      /**
       * Event emitted when a key-specific aftertouch MIDI message has been received on a specific
       * device and channel.
       *
       * @event keyaftertouch
       *
       * @param {Object} event
       * @param {MIDIInput} event.device    The MIDI input device that triggered the event.
       * @param {Uint8Array} event.data     The raw MIDI message as an array of 8 bit
       *                                    values.
       * @param {Number} event.receivedTime The time when the event occurred (in milliseconds since
       *                                    start).
       * @param {uint} event.timeStamp      The timestamp when the event occurred (in milliseconds
       *                                    since the epoch).
       * @param {uint} event.channel        The channel where the event occurred (between 1 and 16).
       * @param {String} event.type         The type of event that occurred.
       * @param {Object} event.note
       * @param {uint} event.note.number    The MIDI note number.
       * @param {String} event.note.name    The usual note name (C, C#, D, D#, etc.).
       * @param {uint} event.note.octave    The octave (between -2 and 8).
       * @param {Number} event.value        The aftertouch amount (between 0 and 1).
       */
      event.type = &#x27;keyaftertouch&#x27;;
      event.note = {
        &quot;number&quot;: data1,
        &quot;name&quot;: _notes[data1 % 12],
        &quot;octave&quot;: Math.floor(data1 / 12 - 1) - 3
      };
      event.value = data2 / 127;

    } else if (
        command === _channelMessages.controlchange &amp;&amp;
        data1 &gt;= 0 &amp;&amp; data1 &lt;= 119
    ) {

      /**
       * Event emitted when a control change MIDI message has been received on a specific device and
       * channel.
       *
       * @event controlchange
       *
       * @param {Object} event
       * @param {MIDIInput} event.device    The MIDI input device that triggered the event.
       * @param {Uint8Array} event.data     The raw MIDI message as an array of 8 bit
       *                                    values.
       * @param {Number} event.receivedTime The time when the event occurred (in milliseconds since
       *                                    start).
       * @param {uint} event.timeStamp      The timestamp when the event occurred (in milliseconds
       *                                    since the epoch).
       * @param {uint} event.channel        The channel where the event occurred (between 1 and 16).
       * @param {String} event.type         The type of event that occurred.
       * @param {Object} event.controller
       * @param {uint} event.controller.number     The number of the controller.
       * @param {String} event.controller.name     The number of the controller.
       * @param {uint} event.value          The value received (between 0 and 127).
       */
      event.type = &#x27;controlchange&#x27;;
      event.controller = {
        &quot;number&quot;: data1,
        &quot;name&quot;: &quot;&quot;
      };
      event.value = data2;

    } else if (
        command === _channelMessages.channelmode &amp;&amp;
        data1 &gt;= 120 &amp;&amp; data1 &lt;= 127
    ) {

      /**
       * Event emitted when a channel mode MIDI message has been received on a specific device and
       * channel.
       *
       * @event channelmode
       *
       * @param {Object} event
       * @param {MIDIInput} event.device    The MIDI input device that triggered the event.
       * @param {Uint8Array} event.data     The raw MIDI message as an array of 8 bit
       *                                    values.
       * @param {Number} event.receivedTime The time when the event occurred (in milliseconds since
       *                                    start).
       * @param {uint} event.timeStamp      The timestamp when the event occurred (in milliseconds
       *                                    since the epoch).
       * @param {uint} event.channel        The channel where the event occurred (between 1 and 16).
       * @param {String} event.type         The type of event that occurred.
       * @param {Object} event.controller
       * @param {uint} event.controller.number     The number of the controller.
       * @param {String} event.controller.name     The number of the controller.
       * @param {uint} event.value          The value received (between 0 and 127).
       */
      event.type = &#x27;channelmode&#x27;;
      event.controller = {
        &quot;number&quot;: data1,
        &quot;name&quot;: &quot;&quot;
      };
      event.value = data2;

    } else if (command === _channelMessages.programchange) {

      /**
       * Event emitted when a program change MIDI message has been received on a specific device and
       * channel.
       *
       * @event programchange
       *
       * @param {Object} event
       * @param {MIDIInput} event.device    The MIDI input device that triggered the event.
       * @param {Uint8Array} event.data     The raw MIDI message as an array of 8 bit
       *                                    values.
       * @param {Number} event.receivedTime The time when the event occurred (in milliseconds since
       *                                    start).
       * @param {uint} event.timeStamp      The timestamp when the event occurred (in milliseconds
       *                                    since the epoch).
       * @param {uint} event.channel        The channel where the event occurred (between 1 and 16).
       * @param {String} event.type         The type of event that occurred.
       * @param {uint} event.value          The value received (between 0 and 127).
       */
      event.type = &#x27;programchange&#x27;;
      event.value = data1;

    } else if (command === _channelMessages.channelaftertouch) {

      /**
       * Event emitted when a channel-wide aftertouch MIDI message has been received on a specific
       * device and channel.
       *
       * @event channelaftertouch
       *
       * @param {Object} event
       * @param {MIDIInput} event.device    The MIDI input device that triggered the event.
       * @param {Uint8Array} event.data     The raw MIDI message as an array of 8 bit
       *                                    values.
       * @param {Number} event.receivedTime The time when the event occurred (in milliseconds since
       *                                    start).
       * @param {uint} event.timeStamp      The timestamp when the event occurred (in milliseconds
       *                                    since the epoch).
       * @param {uint} event.channel        The channel where the event occurred (between 1 and 16).
       * @param {String} event.type         The type of event that occurred.
       * @param {Number} event.value        The aftertouch value received (between 0 and 1).
       */
      event.type = &#x27;channelaftertouch&#x27;;
      event.value = data1 / 127;

    } else if (command === _channelMessages.pitchbend) {

      /**
       * Event emitted when a pitch bend MIDI message has been received on a specific device and
       * channel.
       *
       * @event pitchbend
       *
       * @param {Object} event
       * @param {MIDIInput} event.device    The MIDI input device that triggered the event.
       * @param {Uint8Array} event.data     The raw MIDI message as an array of 8 bit values.
       * @param {Number} event.receivedTime The time when the event occurred (in milliseconds since
       *                                    start).
       * @param {uint} event.timeStamp      The timestamp when the event occurred (in milliseconds
       *                                    since the epoch).
       * @param {uint} event.channel        The channel where the event occurred (between 1 and 16).
       * @param {String} event.type         The type of event that occurred.
       * @param {Number} event.value        The pitch bend value received (between -1 and
       *                                    1).
       */
      event.type = &#x27;pitchbend&#x27;;
      event.value = ((data2 &lt;&lt; 7) + data1 - 8192) / 8192;
    } else {
      event.type = &#x27;unknownchannelmessage&#x27;;
    }

    // If some callbacks have been defined for this event, on that device and channel, execute them.
    if (
        _userHandlers.channel[event.type][event.device.id] &amp;&amp;
        _userHandlers.channel[event.type][event.device.id][channel]
    ) {
      _userHandlers.channel[event.type][event.device.id][channel].forEach(
          function(callback) { callback(event); }
      );
    }

  }

  /**
   * @method _parseSystemEvent
   * @private
   */
  function _parseSystemEvent(e) {

    var command = e.data[0];

    // Returned event
    var event = {
      &quot;device&quot;: e.currentTarget,
      &quot;data&quot;: e.data,
      &quot;receivedTime&quot;: e.receivedTime,
      &quot;timeStamp&quot;: e.timeStamp
    };

    if (command === _systemMessages.sysex) {

      /**
       * Event emitted when a system exclusive MIDI message has been received.
       *
       * @event sysex
       *
       * @param {Object} event
       * @param {MIDIInput} event.device    The MIDI input device that triggered the event.
       * @param {Uint8Array} event.data     The raw MIDI message as an array of 8 bit
       *                                    values.
       * @param {Number} event.receivedTime The time when the event occurred (in
       *                                    milliseconds since start).
       * @param {uint} event.timeStamp      The timestamp when the event occurred
       *                                    (in milliseconds since the epoch).
       * @param {String} event.type         The type of event that occurred.
       */
      event.type = &#x27;sysex&#x27;;

    } else if (command === _systemMessages.timecode) {

      /**
       * Event emitted when a system MIDI time code quarter frame message has been received.
       *
       * @event timecode
       *
       * @param {Object} event
       * @param {MIDIInput} event.device    The MIDI input device that triggered the event.
       * @param {Uint8Array} event.data     The raw MIDI message as an array of 8 bit values.
       * @param {Number} event.receivedTime The time when the event occurred (in
       *                                    milliseconds since start).
       * @param {uint} event.timeStamp      The timestamp when the event occurred
       *                                    (in milliseconds since the epoch).
       * @param {String} event.type         The type of event that occurred.
       */
      event.type = &#x27;timecode&#x27;;

      //@todo calculate time values and make them directly available

    } else if (command === _systemMessages.songposition) {

      /**
       * Event emitted when a system song position pointer MIDI message has been received.
       *
       * @event songposition
       *
       * @param {Object} event
       * @param {MIDIInput} event.device    The MIDI input device that triggered the event.
       * @param {Uint8Array} event.data     The raw MIDI message as an array of 8 bit values.
       * @param {Number} event.receivedTime The time when the event occurred (in
       *                                    milliseconds since start).
       * @param {uint} event.timeStamp      The timestamp when the event occurred
       *                                    (in milliseconds since the epoch).
       * @param {String} event.type         The type of event that occurred.
       */
      event.type = &#x27;songposition&#x27;;

      //@todo calculate position value and make it directly available

    } else if (command === _systemMessages.songselect) {

      /**
       * Event emitted when a system song select MIDI message has been received.
       *
       * @event songselect
       *
       * @param {Object} event
       * @param {MIDIInput} event.device    The MIDI input device that triggered the event.
       * @param {Uint8Array} event.data     The raw MIDI message as an array of 8 bit
       *                                    values.
       * @param {Number} event.receivedTime The time when the event occurred (in
       *                                    milliseconds since start).
       * @param {uint} event.timeStamp      The timestamp when the event occurred
       *                                    (in milliseconds since the epoch).
       * @param {String} event.type         The type of event that occurred.
       * @param {String} event.song         Song (or sequence) number to select.
       */
      event.type = &#x27;songselect&#x27;;
      event.song = e.data[1];

    } else if (command === _systemMessages.tuningrequest) {

      /**
       * Event emitted when a system tune request MIDI message has been received.
       *
       * @event tuningrequest
       *
       * @param {Object} event
       * @param {MIDIInput} event.device    The MIDI input device that triggered the event.
       * @param {Uint8Array} event.data     The raw MIDI message as an array of 8 bit
       *                                    values.
       * @param {Number} event.receivedTime The time when the event occurred (in
       *                                    milliseconds since start).
       * @param {uint} event.timeStamp      The timestamp when the event occurred
       *                                    (in milliseconds since the epoch).
       * @param {String} event.type         The type of event that occurred.
       */
      event.type = &#x27;tuningrequest&#x27;;

    } else if (command === _systemMessages.clock) {

      /**
       * Event emitted when a system timing clock MIDI message has been received.
       *
       * @event clock
       *
       * @param {Object} event
       * @param {MIDIInput} event.device    The MIDI input device that triggered the event.
       * @param {Uint8Array} event.data     The raw MIDI message as an array of 8 bit
       *                                    values.
       * @param {Number} event.receivedTime The time when the event occurred (in
       *                                    milliseconds since start).
       * @param {uint} event.timeStamp      The timestamp when the event occurred
       *                                    (in milliseconds since the epoch).
       * @param {String} event.type         The type of event that occurred.
       */
      event.type = &#x27;clock&#x27;;

    } else if (command === _systemMessages.start) {

      /**
       * Event emitted when a system start MIDI message has been received.
       *
       * @event start
       *
       * @param {Object} event
       * @param {MIDIInput} event.device    The MIDI input device that triggered the event.
       * @param {Uint8Array} event.data     The raw MIDI message as an array of 8 bit
       *                                    values.
       * @param {Number} event.receivedTime The time when the event occurred (in
       *                                    milliseconds since start).
       * @param {uint} event.timeStamp      The timestamp when the event occurred
       *                                    (in milliseconds since the epoch).
       * @param {String} event.type         The type of event that occurred.
       */
      event.type = &#x27;start&#x27;;

    } else if (command === _systemMessages.continue) {

      /**
       * Event emitted when a system continue MIDI message has been received.
       *
       * @event continue
       *
       * @param {Object} event
       * @param {MIDIInput} event.device    The MIDI input device that triggered the event.
       * @param {Uint8Array} event.data     The raw MIDI message as an array of 8 bit
       *                                    values.
       * @param {Number} event.receivedTime The time when the event occurred (in
       *                                    milliseconds since start).
       * @param {uint} event.timeStamp      The timestamp when the event occurred
       *                                    (in milliseconds since the epoch).
       * @param {String} event.type         The type of event that occurred.
       */
      event.type = &#x27;continue&#x27;;

    } else if (command === _systemMessages.stop) {

      /**
       * Event emitted when a system stop MIDI message has been received.
       *
       * @event stop
       *
       * @param {Object} event
       * @param {MIDIInput} event.device    The MIDI input device that triggered the event.
       * @param {Uint8Array} event.data     The raw MIDI message as an array of 8 bit
       *                                    values.
       * @param {Number} event.receivedTime The time when the event occurred (in
       *                                    milliseconds since start).
       * @param {uint} event.timeStamp      The timestamp when the event occurred
       *                                    (in milliseconds since the epoch).
       * @param {String} event.type         The type of event that occurred.
       */
      event.type = &#x27;stop&#x27;;

    } else if (command === _systemMessages.activesensing) {

      /**
       * Event emitted when a system active sensing MIDI message has been received.
       *
       * @event activesensing
       *
       * @param {Object} event
       * @param {MIDIInput} event.device    The MIDI input device that triggered the event.
       * @param {Uint8Array} event.data     The raw MIDI message as an array of 8 bit
       *                                    values.
       * @param {Number} event.receivedTime The time when the event occurred (in
       *                                    milliseconds since start).
       * @param {uint} event.timeStamp      The timestamp when the event occurred
       *                                    (in milliseconds since the epoch).
       * @param {String} event.type         The type of event that occurred.
       */
      event.type = &#x27;activesensing&#x27;;

    } else if (command === _systemMessages.reset) {

      /**
       * Event emitted when a system reset MIDI message has been received.
       *
       * @event reset
       *
       * @param {Object} event
       * @param {MIDIInput} event.device    The MIDI input device that triggered the event.
       * @param {Uint8Array} event.data     The raw MIDI message as an array of 8 bit
       *                                    values.
       * @param {Number} event.receivedTime The time when the event occurred (in
       *                                    milliseconds since start).
       * @param {uint} event.timeStamp      The timestamp when the event occurred
       *                                    (in milliseconds since the epoch).
       * @param {String} event.type         The type of event that occurred.
       */
      event.type = &#x27;reset&#x27;;

    } else {

      /**
       * Event emitted when an unknown system MIDI message has been received. It could be,
       * for example, one of the undefined/reserved messages.
       *
       * @event unknownsystemmessage
       *
       * @param {Object} event
       * @param {MIDIInput} event.device    The MIDI input device that triggered the event.
       * @param {Uint8Array} event.data     The raw MIDI message as an array of 8 bit
       *                                    values.
       * @param {Number} event.receivedTime The time when the event occurred (in
       *                                    milliseconds since start).
       * @param {uint} event.timeStamp      The timestamp when the event occurred
       *                                    (in milliseconds since the epoch).
       * @param {String} event.type         The type of event that occurred.
       */
      event.type = &#x27;unknownsystemmessage&#x27;;

    }

    // If some callbacks have been defined for this event, execute them.
    if (_userHandlers.system[event.type]) {
      _userHandlers.system[event.type].forEach(
          function(callback) { callback(event); }
      );
    }

  }

  /**
   * @method _onMidiMessage
   * @private
   */
  function _onMidiMessage(e) {

    if (e.data[0] &lt; 240) {          // device and channel-specific message
      _parseChannelEvent(e);
    } else if (e.data[0] &lt;= 255) {  // system message
      _parseSystemEvent(e);
    }

  }

  /**
   * Checks if the Web MIDI API is available and then tries to connect to the host&#x27;s MIDI
   * subsystem. If the operation succeeds, the &#x60;successHandler&#x60; callback is executed.
   * If not, the &#x60;errorHandler&#x60; callback is executed and passed a string describing the
   * error.
   *
   * @method enable
   * @static
   *
   * @param [successHandler] {Function} A function to execute upon success.
   * @param [errorHandler] {Function}   A function to execute upon error. This function
   *                                    will be passed a string describing the error.
   * @param [sysex=false] {Boolean}     Whether to enable sysex or not. When this
   *                                    parameter is set to true, the browser may prompt
   *                                    the user for authorization.
   */
  WebMidi.prototype.enable = function(successHandler, errorHandler, sysex) {

    var that = this;

    if (
        (successHandler &amp;&amp; typeof successHandler !== &quot;function&quot;) ||
        (errorHandler &amp;&amp; typeof errorHandler !== &quot;function&quot;)
    ) {
      throw new TypeError(&quot;The success and error handlers must be functions.&quot;);
    }

    if (!this.supported &amp;&amp; errorHandler) {
      errorHandler(&quot;The Web MIDI API is not supported by your browser.&quot;);
      return;
    }

    navigator.requestMIDIAccess({&quot;sysex&quot;: sysex}).then(

        function(midiAccess) {
          that.interface = midiAccess;

          that.interface.onstatechange = _onInterfaceStateChange;

          that.inputs.forEach(function(input) {
            input.onmidimessage = _onMidiMessage;
          });

          if (successHandler) { successHandler(); }

        },
        errorHandler
    );

  };

  /**
   * Adds an event listener that will trigger a function callback when the specified event
   * happens. By default, the listener is system-wide (it will listen on all MIDI
   * channels of all MIDI devices). To listen to a specific device or channel, you can use the
   * &#x60;filter&#x60; parameter.
   *
   * WebMidi must be enabled before adding event listeners.
   *
   * Here is a list of events that are dispatched by the &#x60;WebMidi&#x60; object and that can be
   * listened to.
   *
   * MIDI interface event:
   *
   *    * {{#crossLink &quot;WebMidi/statechange:event&quot;}}statechange{{/crossLink}}
   *
   * Device and channel-specific MIDI events:
   *
   *    * {{#crossLink &quot;WebMidi/noteoff:event&quot;}}noteoff{{/crossLink}}
   *    * {{#crossLink &quot;WebMidi/noteon:event&quot;}}noteon{{/crossLink}}
   *    * {{#crossLink &quot;WebMidi/keyaftertouch:event&quot;}}keyaftertouch{{/crossLink}}
   *    * {{#crossLink &quot;WebMidi/controlchange:event&quot;}}controlchange{{/crossLink}}
   *    * {{#crossLink &quot;WebMidi/channelmode:event&quot;}}channelmode{{/crossLink}}
   *    * {{#crossLink &quot;WebMidi/programchange:event&quot;}}programchange{{/crossLink}}
   *    * {{#crossLink &quot;WebMidi/channelaftertouch:event&quot;}}channelaftertouch{{/crossLink}}
   *    * {{#crossLink &quot;WebMidi/pitchbend:event&quot;}}pitchbend{{/crossLink}}
   *
   * System-wide MIDI events:
   *
   *    * {{#crossLink &quot;WebMidi/sysex:event&quot;}}sysex{{/crossLink}}
   *    * {{#crossLink &quot;WebMidi/timecode:event&quot;}}timecode{{/crossLink}}
   *    * {{#crossLink &quot;WebMidi/songposition:event&quot;}}songposition{{/crossLink}}
   *    * {{#crossLink &quot;WebMidi/songselect:event&quot;}}songselect{{/crossLink}}
   *    * {{#crossLink &quot;WebMidi/tuningrequest:event&quot;}}tuningrequest{{/crossLink}}
   *    * {{#crossLink &quot;WebMidi/clock:event&quot;}}clock{{/crossLink}}
   *    * {{#crossLink &quot;WebMidi/start:event&quot;}}start{{/crossLink}}
   *    * {{#crossLink &quot;WebMidi/continue:event&quot;}}continue{{/crossLink}}
   *    * {{#crossLink &quot;WebMidi/stop:event&quot;}}stop{{/crossLink}}
   *    * {{#crossLink &quot;WebMidi/activesensing:event&quot;}}activesensing{{/crossLink}}
   *    * {{#crossLink &quot;WebMidi/reset:event&quot;}}reset{{/crossLink}}
   *    * {{#crossLink &quot;WebMidi/unknownsystemmessage:event&quot;}}unknownsystemmessage{{/crossLink}}
   *
   * For system-wide events, the &#x60;filters&#x60; parameter (if any) will be silently ignored.
   *
   * @method addListener
   * @static
   * @chainable
   *
   * @param type {String}                             The type of the event.
   * @param listener {Function}                       A callback function to execute when the
   *                                                  specified event is detected. This function
   *                                                  will receive an event parameter object.
   *                                                  For details on this object&#x27;s properties,
   *                                                  check out the documentation for the various
   *                                                  events (links above).
   *
   * @param [filters={}]
   * @param [filters.device=&quot;all&quot;] {String|Array}     The id of the MIDI device to listen on. The
   *                                                  device id can be retrieved in the
   *                                                  &#x60;WebMidi.inputs&#x60; array. It is also possible
   *                                                  to listen on several devices at once by
   *                                                  passing in an array of ids. If set to
   *                                                  &#x27;all&#x27; (default) all devices will trigger the
   *                                                  callback function.
   * @param [filters.channel=&quot;all&quot;] {uint|Array|String}  The MIDI channel to listen on (between 1 and
   *                                                  16). You can also specify an array of channels
   *                                                  to listen on. If set to &#x27;all&#x27;, all channels
   *                                                  will trigger the callback function.
   *
   * @throws {Error}                                  WebMidi must be connected before adding event
   *                                                  listeners.
   * @throws {Error}                                  There is no device with the requested id.
   * @throws {RangeError}                             The channel must be an integer between 1 and
   *                                                  16 or the value &#x27;all&#x27;.
   * @throws {TypeError}                              The specified event type is not supported.
   * @throws {TypeError}                              The &#x27;listener&#x27; parameter must be a function.
   *
   * @return {WebMidi}                                Returns the &#x60;WebMidi&#x60; object so methods
   *                                                  can be chained.
   */
  WebMidi.prototype.addListener = function(type, listener, filters) {

    var that = this;

    if (!this.connected) {
      throw new Error(&quot;WebMidi must be connected before adding event listeners.&quot;);
    }

    filters = filters || {};

    if (filters.device === undefined) { filters.device = &quot;all&quot;; }
    if (filters.device.constructor !== Array) { filters.device = [filters.device]; }

    if (filters.channel === undefined) { filters.channel = &quot;all&quot;; }
    if (filters.channel.constructor !== Array) { filters.channel = [filters.channel]; }

    // Check if device entries are valid
    filters.device.forEach(function(item) {

      if (item !== &quot;all&quot; &amp;&amp; !that.getDeviceById(item, &#x27;input&#x27;)) {
        throw new Error(
            &quot;There is no device with the requested id.&quot;
        );
      }
    });

    // Check if channel entries are valid
    filters.channel.forEach(function(item){
      if (item !== &quot;all&quot; &amp;&amp; !(item &gt;= 1 &amp;&amp; item &lt;= 16)) {
        throw new RangeError(
            &quot;The channel must be an integer between 1 and 16 or the value &#x27;all&#x27;.&quot;
        );
      }
    });

    if (typeof listener !== &quot;function&quot;) {
      throw new TypeError(&quot;The &#x27;listener&#x27; parameter must be a function.&quot;);
    }

    if (type === &quot;statechange&quot; || _systemMessages[type]) {

      _userHandlers.system[type].push(listener);

    } else if (_channelMessages[type]) {

      // If &quot;all&quot; is present anywhere in the device array, add all currently-available devices
      if (filters.device.indexOf(&quot;all&quot;) &gt; -1) {
        filters.device = [];
        for (var i = 0; i &lt; that.inputs.length; i++) {
          filters.device.push(that.inputs[i].id);
        }
      }

      // If &quot;all&quot; is present anywhere in the channel array, use all 16 channels
      if (filters.channel.indexOf(&quot;all&quot;) &gt; -1) {
        filters.channel = [];
        for (var j = 1; j &lt;= 16; j++) { filters.channel.push(j); }
      }


      if (!_userHandlers.channel[type]) { _userHandlers.channel[type] = []; }

      // Go through all specified devices
      filters.device.forEach(function(dev) {

        // Create device array if non-existent (using the device&#x27;s id)
        if ( !_userHandlers.channel[type][dev] ) {
          _userHandlers.channel[type][dev] = []; }

        // Push all channel listeners in the device array
        filters.channel.forEach(function(ch){

          if (!_userHandlers.channel[type][dev][ch]) {
            _userHandlers.channel[type][dev][ch] = [];
          }

          _userHandlers.channel[type][dev][ch].push(listener);

        });

      });

    } else {
      throw new TypeError(&quot;The specified event type is not supported.&quot;);
    }

    return this;

  };

  /**
   *
   * Returns a MIDIOutput or MIDIInput device matching the specified id and device type.
   *
   * @method getDeviceById
   * @static
   *
   * @param id {String}                     The id of the device. Ids can be retrieved by looking at
   *                                        the &#x60;WebMidi.inputs&#x60; or &#x60;WebMidi.outputs&#x60; arrays.
   * @param [type=input] {String}           One of &#x27;input&#x27; or &#x27;output&#x27; to indicate whether your are
   *                                        looking for an input or an output device.
   * @returns {MIDIOutput|MIDIInput|False}  A MIDIOutput or MIDIInput device matching the specified
   *                                        id. If no matching device can be found, the method
   *                                        returns &#x60;false&#x60;.
   */
  WebMidi.prototype.getDeviceById = function(id, type) {

    var devices = (type === &quot;output&quot;) ? this.outputs : this.inputs;

    for (var i = 0; i &lt; devices.length; i++) {
      if (devices[i].id === id) { return devices[i]; }
    }

    return false;

  };

  /**
   * Return the index of a device in the &#x60;WebMidi.outputs&#x60; or &#x60;WebMidi.inputs&#x60; arrays. The device
   * must be specified by using its id.
   *
   * @method getDeviceIndexById
   * @static
   *
   * @param id {String}             The id of the device such as it is presented in the
   *                                &#x60;WebMidi.inputs&#x60; or &#x60;WebMidi.outputs&#x60; arrays.
   * @param [type=input] {String}   One of &#x27;input&#x27; or &#x27;output&#x27; to indicate whether your are looking
   *                                for the index of an input or output device.
   * @returns {uint|False}          If no matching device can be found, the method returns &#x60;false&#x60;.
   */
  WebMidi.prototype.getDeviceIndexById = function(id, type) {

    var devices = (type === &quot;output&quot;) ? this.outputs : this.inputs;

    for (var i = 0; i &lt; devices.length; i++) {
      if (devices[i].id === id) { return i; }
    }

    return false;

  };

  /**
   * Checks if the specified event type is already defined to trigger the listener function on the
   * specified device and channel. If the special value &quot;all&quot; is used for the device/channel, the
   * function will return &#x60;true&#x60; only if all devices/channels have the listener defined.
   *
   * For system-wide events (&#x60;onstatechange&#x60;, &#x60;sysex&#x60;, &#x60;start&#x60;, etc.), the &#x60;filters&#x60; parameter is
   * silently ignored.
   *
   * @method hasListener
   * @static
   *
   * @param type {String}                               The type of the event.
   * @param listener {Function}                         The callback function to check for.
   * @param [filters={}] {Object}
   * @param [filters.device=&quot;all&quot;] {String|Array}       The id of the MIDI device to check on (as
   *                                                    reported by &#x60;WebMidi.inputs&#x60;) or the special
   *                                                    value &quot;all&quot;.
   * @param [filters.channel=all] {uint|Array|String}   The MIDI channel to check on. It can be a
   *                                                    uint (between 1 and 16) or the special value
   *                                                    &quot;all&quot;.
   *
   * @throws {Error}                                    WebMidi must be enabled before checking
   *                                                    event listeners.
   * @throws {TypeError}                                The &#x27;listener&#x27; parameter must be a function.
   *
   * @return {Boolean}                                  Boolean value indicating whether or not the
   *                                                    channel(s) already have this listener
   *                                                    defined.
   */
  WebMidi.prototype.hasListener = function(type, listener, filters) {

    var that = this;

    if (!this.connected) {
      throw new Error(&quot;WebMidi must be connected before checking event listeners.&quot;);
    }

    if (typeof listener !== &quot;function&quot;) {
      throw new TypeError(&quot;The &#x27;listener&#x27; parameter must be a function.&quot;);
    }

    filters = filters || {};

    if (filters.device === undefined) { filters.device = &quot;all&quot;; }
    if (filters.device.constructor !== Array) { filters.device = [filters.device]; }

    if (filters.channel === undefined) { filters.channel = &quot;all&quot;; }
    if (filters.channel.constructor !== Array) { filters.channel = [filters.channel]; }

    if (type === &quot;statechange&quot; || _systemMessages[type]) {

      for (var o = 0; o &lt; _userHandlers.system[type].length; o++) {
        if (_userHandlers.system[type][o] === listener) { return true; }
      }

    } else if (_channelMessages[type]) {

      // If &quot;all&quot; is present anywhere in the device array, add all currently-available devices
      if (filters.device.indexOf(&quot;all&quot;) &gt; -1) {
        filters.device = [];
        for (var i = 0; i &lt; that.inputs.length; i++) {
          filters.device.push(that.inputs[i].id);
        }
      }

      // If &quot;all&quot; is present anywhere in the channel array, use all 16 channels
      if (filters.channel.indexOf(&quot;all&quot;) &gt; -1) {
        filters.channel = [];
        for (var j = 1; j &lt;= 16; j++) { filters.channel.push(j); }
      }

      if (!_userHandlers.channel[type]) { return false; }

      // Go through all specified devices
      return filters.device.every(function(devId) {

        if (!_userHandlers.channel[type][devId]) { return false; }

        // Go through all specified channels
        return filters.channel.every(function(chNum) {
          var listeners = _userHandlers.channel[type][devId][chNum];
          return listeners &amp;&amp; listeners.indexOf(listener) &gt; -1;
        });

      });

    }

    return false;

  };

  /**
   * Removes the specified listener from all requested devices and channel(s). If the special value
   * &quot;all&quot; is used for the device or the channel parameter, the function will remove the listener
   * from all devices/channels.
   *
   * For system-wide events (&#x60;onstatechange&#x60;, &#x60;sysex&#x60;, &#x60;start&#x60;, etc.), the &#x60;filters&#x60; parameter is
   * silently ignored.
   *
   * @method removeListener
   * @static
   * @chainable
   *
   * @param type {String}                         The type of the event.
   * @param listener {Function}                   The callback function to check for.
   * @param [filters={}] {Object}
   * @param [filters.device=all] {String}         The id of the device(s) to check on or the special
   *                                              value &quot;all&quot;.
   * @param [filters.channel=all] {uint|String}   The MIDI channel(s) to check on. It can be a uint
   *                                              (between 1 and 16) or the special value &quot;all&quot;.
   *
   * @throws {Error}                              WebMidi must be enabled before removing event
   *                                              listeners.
   *
   * @return {WebMidi}                            The &#x60;WebMidi&#x60; object for easy method chaining.
   */
  WebMidi.prototype.removeListener = function(type, listener, filters) {

    var that = this;

    if (!this.connected) {
      throw new Error(&quot;WebMidi must be connected before removing event listeners.&quot;);
    }

    filters = filters || {};

    if (filters.device === undefined) { filters.device = &quot;all&quot;; }
    if (filters.device.constructor !== Array) { filters.device = [filters.device]; }

    if (filters.channel === undefined) { filters.channel = &quot;all&quot;; }
    if (filters.channel.constructor !== Array) { filters.channel = [filters.channel]; }

    if (type === &quot;statechange&quot; || _systemMessages[type]) {

      for (var o = 0; o &lt; _userHandlers.system[type].length; o++) {
        if (_userHandlers.system[type][o] === listener) {
          _userHandlers.system[type].splice(o, 1);
        }
      }

    } else if (_channelMessages[type]) {

      // If &quot;all&quot; is present anywhere in the device array, add all currently-available devices
      if (filters.device.indexOf(&quot;all&quot;) &gt; -1) {
        filters.device = [];
        for (var i = 0; i &lt; that.inputs.length; i++) {
          filters.device.push(that.inputs[i].id);
        }
      }

      // If &quot;all&quot; is present anywhere in the channel array, use all 16 channels
      if (filters.channel.indexOf(&quot;all&quot;) &gt; -1) {
        filters.channel = [];
        for (var j = 1; j &lt;= 16; j++) { filters.channel.push(j); }
      }

      if (!_userHandlers.channel[type]) { return false; }

      // Go through all specified devices
      filters.device.forEach(function(devId) {

        if (!_userHandlers.channel[type][devId]) { return; }

        // Go through all specified channels
        filters.channel.forEach(function(chNum) {
          var listeners = _userHandlers.channel[type][devId][chNum];
          if (!listeners) { return; }
          for (var l = 0; l &lt; listeners.length; l++) {
            if (listeners[l] === listener) { listeners.splice(l, 1); }
          }

        });

      });

    }

    return this;

  };

  /**
   * Sends a MIDI message to the specified device(s) at the specified timestamp. The &#x60;device&#x60;
   * parameter must be the id of an available device as reported by &#x60;WebMidi.outputs&#x60;. It can also
   * be an array of such devices or the value &quot;all&quot;. By using &quot;all&quot;, the message will be sent to all
   * currently available output devices.
   *
   * Unless, you are familiar with the details of the MIDI message format, you should not use this
   * method directly. Instead, use one of the simpler helper methods: &#x60;playNote()&#x60;, &#x60;stopNote()&#x60;,
   * &#x60;sendControlChange()&#x60;, &#x60;sendSystemMessage()&#x60;, etc.
   *
   * Details on the format of MIDI messages are available in the
   * &lt;a href=&quot;http://www.midi.org/techspecs/midimessages.php&quot;&gt;summary of MIDI messages&lt;/a&gt; of the
   * MIDI Manufacturers Association.
   *
   * @method send
   * @static
   * @chainable
   *
   * @param status {uint}                         The MIDI status byte of the message (128-255).
   * @param [data=[]] {Array}                     An array of data bytes for the message. The number
   *                                              of data bytes varies depending on the status byte.
   * @param [device=&quot;all&quot;] {String|Array}         The id of the device the message should be sent
   *                                              to. You can view the device ids by looking at
   *                                              &#x60;WebMidi.outputs&#x60;. If you leave out this parameter
   *                                              the message will be sent to all devices.
   * @param [timestamp=0] {DOMHighResTimeStamp}   The timestamp at which to send the message. You
   *                                              can use &#x60;WebMidi.time&#x60; to retrieve the current
   *                                              timestamp. To send immediately, leave blank or use
   *                                              0.
   *
   * @throws {Error}                              WebMidi must be connected before sending messages.
   * @throws {ReferenceError}                     There is no device matching the requested id.
   * @throws {RangeError}                         The status byte must be an integer between 128
   *                                              (0x80) and 255 (0xFF).
   *
   * @return {WebMidi}                            Returns the &#x60;WebMidi&#x60; object so methods can be
   *                                              chained.
   */
  WebMidi.prototype.send = function(status, data, device, timestamp) {

    var that = this;

    if (!this.connected) { throw new Error(&quot;WebMidi must be connected before sending messages.&quot;); }

    if (status === undefined || status &lt; 128 || status &gt; 255) {
      throw new RangeError(&quot;The status byte must be an integer between 128 (0x80) and 255 (0xFF).&quot;);
    }

    if (data === undefined || data.constructor !== Array) { data = []; }
    if (device === undefined) { device = [&#x27;all&#x27;]; }

    if (device.constructor !== Array) { device = [device]; }

    // Check if device entries are valid
    device.forEach(function(dev) {
      if (dev !== &quot;all&quot; &amp;&amp; !that.getDeviceById(dev, &#x27;output&#x27;)) {
        throw new ReferenceError(&quot;There is no device matching the requested id (&quot; + dev + &quot;).&quot;);
      }
    });

    // If &quot;all&quot; is present anywhere, add all outputs to device array
    if (device.indexOf(&quot;all&quot;) &gt; -1) {
      device = [];
      this.outputs.forEach(function(output) {
        device.push(output.id);
      });
    }

    if (timestamp === undefined) { timestamp = 0; }

    var message = [status];

    data.forEach(function(item){
      if (item !== undefined) { message.push(item); }
    });

    device.forEach(function(dev) {
      that.outputs[that.getDeviceIndexById(dev, &#x27;output&#x27;)].send(message, timestamp);
    });

    return this;

  };

  ///**
  // * Sends a MIDI real-time or common system message to all available outputs. The available
  // * messages are as follows:
  // *
  // * System common messages:
  // *
  // *    sysex
  // *    timecode
  // *    songposition
  // *    songselect
  // *    tuningrequest
  // *    sysexend
  // *
  // * System real-time messages:
  // *
  // *    clock
  // *    start
  // *    continue
  // *    stop
  // *    activesensing
  // *    reset
  // *
  // * @method sendSystemMessage
  // * @static
  // * @chainable
  // *
  // * @param command {String}    A string representing the command to send. The available system
  // *                            commands are: &#x60;sysex&#x60;, &#x60;timecode&#x60;, &#x60;songposition&#x60;, &#x60;songselect&#x60;,
  // *                            &#x60;tuningrequest&#x60;, &#x60;sysexend&#x60;, &#x60;clock&#x60;, &#x60;start&#x60;, &#x60;continue&#x60;, &#x60;stop&#x60;,
  // *                            &#x60;activesensing&#x60; and &#x60;reset&#x60;.
  // * @param [data=[]] {Array}   An array of data bytes to insert in the message. The number of data
  // *                            bytes varies depending on the command.
  // * @param [delay=0] {uint}    The number of milliseconds to wait before actually sending the
  // *                            message (using 0 will send the message immediately).
  // *
  // * @throws {Error}            WebMidi must be enabled sending messages.
  // * @throws {RangeError}       The requested system command is not supported.
  // *
  // * @return {WebMidi}          Returns the &#x60;WebMidi&#x60; object so methods can be chained.
  // *
  // */
  //WebMidi.prototype.sendSystemMessage = function(command, data, delay) {
  //
  //  if (!this.connected) { throw new Error(&quot;WebMidi must be connected sending messages.&quot;); }
  //
  //  if (!_systemMessages[command]) {
  //    throw new RangeError(&quot;The requested system command (&quot; + command + &quot;) is not supported&quot;);
  //  }
  //
  //  if (!data || data.constructor !== Array) { data = []; }
  //
  //  delay = parseInt(delay);
  //  if (isNaN(delay)) { delay = 0; }
  //
  //  this.send(&quot;all&quot;, _systemMessages[command], data, this.time + delay);
  //
  //  return this;
  //};

  ///**
  // * Sends a system exclusive message to all connected devices. The message will
  // * automatically be properly terminated. It is generally suggested to keep system
  // * exclusive messages to 64Kb or less.
  // *
  // * @method sendSystemMessage
  // * @static
  // * @chainable
  // *
  // * @param manufacturer {uint|Array} A uint or an array of three uints between 0 and 127
  // *                                  that identifies the targeted manufacturer.
  // * @param [data=[]] {Array}         An array of uints between 0 and 127. This is the
  // *                                  data you wish to transfer.
  // * @param [delay=0] {uint}          The number of milliseconds to wait before actually
  // *                                  sending the command (using 0 will send the command
  // *                                  immediately).
  // *
  // * @throws                          WebMidi must be enabled sending messages.
  // *
  // * @return {WebMidi}                Returns the &#x60;WebMidi&#x60; object so methods can be
  // *                                  chained.
  // */
  //WebMidi.prototype.sendSysexMessage = function(manufacturer, data, delay) {
  //
  //  if (!this.connected) {
  //    throw new Error(&quot;WebMidi must be connected before sending messages.&quot;);
  //  }
  //
  //  if (manufacturer.prototype !== Array) { manufacturer = [manufacturer]; }
  //
  //  delay = parseInt(delay);
  //  if (isNaN(delay)) { delay = 0; }
  //
  //  data = manufacturer.concat(data, _systemMessages.sysexend);
  //  this.send(&quot;all&quot;, _systemMessages.sysex, data, this.time + delay);
  //
  //  return this;
  //
  //};

  /**
   * Sends a MIDI &#x60;note off&#x60; message to the specified device(s) and channel(s) for a single note or
   * multiple simultaneous notes (chord). You can delay the execution of the &#x60;note off&#x60; command by
   * using the &#x60;delay&#x60; parameter (milliseconds).
   *
   * @method stopNote
   * @static
   * @chainable
   *
   * @param note {Array|uint|String}      The note or an array of notes to stop. The notes can be
   *                                      specified in one of two ways. The first way is by using
   *                                      the MIDI note number (an integer between 0 and 127). The
   *                                      second way is by using the note name followed by the
   *                                      octave (C3, G#4, F-1). The octave range should be between
   *                                      -2 and 8. The lowest note is C-2 (MIDI note number 0) and
   *                                      the highest note is G8 (MIDI note number 127).
   * @param [velocity=0.5] {Number}       The velocity at which to play the note (between 0 and 1).
   *                                      An invalid velocity value will silently trigger the
   *                                      default.
   * @param [device=&quot;all] {String|Array}  The device id or an array of device ids. You can view
   *                                      available devices in the &#x60;WebMidi.outputs&#x60; array. The
   *                                      special value &quot;all&quot; can also be used.
   * @param [channel=&quot;all] {uint|Array|String}  The MIDI channel number (between 1 and 16) or an
   *                                            array of channel numbers. If the special value &quot;all&quot;
   *                                            is used, the message will be sent to all 16
   *                                            channels.
   * @param [time=undefined] {DOMHighResTimeStamp|String}   This value can be one of two things. If
   *                                      the value is a string starting with the + sign and
   *                                      followed by a number, the request will be delayed by the
   *                                      specified number (in milliseconds). Otherwise, the value
   *                                      is considered a timestamp and the request will be
   *                                      scheduled at that timestamp. The DOMHighResTimeStamp value
   *                                      is relative to the navigation start of the document. To
   *                                      retrieve the current time, you can use &#x60;WebMidi.time&#x60;. If
   *                                      &#x60;time&#x60; is not present or is set to a time in the past,
   *                                      the request is to be sent as soon as possible.
   *
   * @throws {Error}                      WebMidi must be enabled before stopping notes.
   *
   * @return {WebMidi}                    Returns the &#x60;WebMidi&#x60; object so methods can be chained.
   */
  WebMidi.prototype.stopNote = function(note, velocity, device, channel, time) {

    var that = this;

    if (!this.connected) { throw new Error(&quot;WebMidi must be connected before stopping notes.&quot;); }

    velocity = parseFloat(velocity);
    if (isNaN(velocity) || velocity &lt; 0 || velocity &gt; 1) { velocity = 0.5; }

    var nVelocity = Math.round(velocity * 127);

    // Send note off messages
    this._convertNoteToArray(note).forEach(function(item) {

      that._convertChannelToArray(channel).forEach(function(ch) {
        that.send(
            (_channelMessages.noteoff &lt;&lt; 4) + (ch - 1),
            [item, nVelocity],
            device,
            that._parseTimeParameter(time)
        );
      });

    });

    return this;

  };

  /**
   * Requests the playback of a single note or multiple notes on the specified device(s) and
   * channel(s). You can delay the execution of the &#x60;note on&#x60; command by using the &#x60;delay&#x60; parameter
   * (milliseconds).
   *
   * If no duration is specified, the note will play until a matching &#x60;note off&#x60; is sent. If a
   * duration is specified, a &#x60;note off&#x60; will be automatically executed after said duration.
   *
   * Please note that if you do use a duration, the release velocity will always be 64. If you want
   * to tailor the release velocity, you need to use separate &#x60;playNote()&#x60; and &#x60;stopNote()&#x60; calls.
   *
   * @method playNote
   * @static
   * @chainable
   *
   * @param note {Array|uint|String}      The note to play or an array of notes to play. The notes
   *                                      can be specified in one of two ways. The first way is by
   *                                      using the MIDI note number (an integer between 0 and 127).
   *                                      The second way is by using the note name followed by the
   *                                      octave (C3, G#4, F-1). The octave range should be between
   *                                      -2 and 8. The lowest possible note is C-2 and the highest
   *                                      is G8.
   * @param [velocity=0.5] {Number}       The velocity at which to play the note (between 0 and 1).
   *                                      An invalid velocity value will silently trigger the
   *                                      default.
   * @param [duration=undefined] {int}    The number of milliseconds to wait before sending a
   *                                      matching note off event. If left undefined, only a
   *                                      &#x60;note on&#x60; message is sent.
   * @param [device=&quot;all] {String|Array}  The device&#x27;s id. You can view available devices in the
   *                                      &#x60;WebMidi.outputs&#x60; array.
   * @param [channel=&quot;all] {uint|Array|String}  The MIDI channel number (between 1 and 16) or an
   *                                            array of channel numbers. If the special value &quot;all&quot;
   *                                            is used, the message will be sent to all 16
   *                                            channels.
   * @param [time=undefined] {DOMHighResTimeStamp|String}   This value can be one of two things. If
   *                                      the value is a string starting with the + sign and
   *                                      followed by a number, the request will be delayed by the
   *                                      specified number (in milliseconds). Otherwise, the value
   *                                      is considered a timestamp and the request will be
   *                                      scheduled at that timestamp. The DOMHighResTimeStamp value
   *                                      is relative to the navigation start of the document. To
   *                                      retrieve the current time, you can use &#x60;WebMidi.time&#x60;. If
   *                                      &#x60;time&#x60; is not present or is set to a time in the past,
   *                                      the request is to be sent as soon as possible.
   *
   * @throws {Error}                      WebMidi must be enabled before playing notes.
   *
   * @return {WebMidi}                    Returns the &#x60;WebMidi&#x60; object so methods can be chained.
   */
  WebMidi.prototype.playNote = function(note, velocity, duration, device, channel, time) {

    var that = this;

    if (!this.connected) { throw new Error(&quot;WebMidi must be connected before playing notes.&quot;); }

    velocity = parseFloat(velocity);
    if (isNaN(velocity) || velocity &lt; 0 || velocity &gt; 1) { velocity = 0.5; }

    var nVelocity = Math.round(velocity * 127);

    time = that._parseTimeParameter(time) || 0;

    // Send note on messages
    this._convertNoteToArray(note).forEach(function(item) {

      that._convertChannelToArray(channel).forEach(function(ch) {
        that.send(
            (_channelMessages.noteon &lt;&lt; 4) + (ch - 1),
            [item, nVelocity],
            device,
            time
        );
      });

    });

    // Send note off messages (only if a duration has been defined)
    if (duration !== undefined) {

      this._convertNoteToArray(note).forEach(function(item) {

        that._convertChannelToArray(channel).forEach(function(ch) {
          that.send(
              (_channelMessages.noteoff &lt;&lt; 4) + (ch - 1),
              [item, 64],
              device,
              time + duration
          );
        });

      });

    }

    return this;

  };

  /**
   * Sends a MIDI &#x60;key aftertouch&#x60; message to the specified device(s) and channel(s). This is a
   * key-specific aftertouch. For a channel-wide aftertouch message, use
   * {{#crossLink &quot;WebMidi/sendChannelAftertouch:method&quot;}}sendChannelAftertouch(){{/crossLink}}.
   *
   * @method sendKeyAftertouch
   * @static
   * @chainable
   *
   * @param note {Array|uint|String}  The note for which you are sending an aftertouch value. The
   *                                  notes can be specified in one of two ways. The first way is by
   *                                  using the MIDI note number (an integer between 0 and 127). The
   *                                  second way is by using the note name followed by the
   *                                  octave (C3, G#4, F-1). The octave range should be between
   *                                  -2 and 8. The lowest note is C-2 (MIDI note number 0) and
   *                                  the highest note is G8 (MIDI note number 127).
   * @param [pressure=0.5] {Number}   The pressure level to send (between 0 and 1).
   * @param [device=&quot;all] {String|Array}  The device id or an array of device ids. You can view
   *                                      available devices in the &#x60;WebMidi.outputs&#x60; array. The
   *                                      special value &quot;all&quot; can also be used.
   * @param [channel=&quot;all] {uint|Array|String}  The MIDI channel number (between 1 and 16) or an
   *                                            array of channel numbers. If the special value &quot;all&quot;
   *                                            is used, the message will be sent to all 16
   *                                            channels.
   * @param [time=undefined] {DOMHighResTimeStamp|String}   This value can be one of two things. If
   *                                      the value is a string starting with the + sign and
   *                                      followed by a number, the request will be delayed by the
   *                                      specified number (in milliseconds). Otherwise, the value
   *                                      is considered a timestamp and the request will be
   *                                      scheduled at that timestamp. The DOMHighResTimeStamp value
   *                                      is relative to the navigation start of the document. To
   *                                      retrieve the current time, you can use &#x60;WebMidi.time&#x60;. If
   *                                      &#x60;time&#x60; is not present or is set to a time in the past,
   *                                      the request is to be sent as soon as possible.
   *
   * @throws {Error}                  WebMidi must be enabled before sending messages.
   * @throws {RangeError}             The channel must be between 1 and 16.
   *
   * @return {WebMidi}                Returns the &#x60;WebMidi&#x60; object so methods can be chained.
   */
  WebMidi.prototype.sendKeyAftertouch = function(note, pressure, device, channel, time) {

    var that = this;

    if (!this.connected) { throw new Error(&quot;WebMidi must be connected before sending messages.&quot;); }
    if (channel &lt; 1 || channel &gt; 16) { throw new RangeError(&quot;The channel must be between 1 and 16.&quot;); }

    pressure = parseFloat(pressure);
    if (isNaN(pressure) || pressure &lt; 0 || pressure &gt; 1) { pressure = 0.5; }

    var nPressure = Math.round(pressure * 127);

    this._convertNoteToArray(note).forEach(function(item) {

      that._convertChannelToArray(channel).forEach(function(ch) {
        that.send(
            (_channelMessages.keyaftertouch &lt;&lt; 4) + (ch - 1),
            [item, nPressure],
            device,
            that._parseTimeParameter(time)
        );
      });

    });

    return this;

  };

  /**
   * Sends a MIDI &#x60;control change&#x60; message to the specified device(s) and channel(s).
   *
   * @method sendControlChange
   * @static
   * @chainable
   *
   * @param controller {uint}             The MIDI controller number (0-119)
   * @param [value=0] {uint}              The value to send (0-127).
   * @param [device=&quot;all] {String|Array}  The device id or an array of device ids. You can view
   *                                      available devices in the &#x60;WebMidi.outputs&#x60; array. The
   *                                      special value &quot;all&quot; can also be used.
   * @param [channel=&quot;all] {uint|Array|String}  The MIDI channel number (between 1 and 16) or an
   *                                            array of channel numbers. If the special value &quot;all&quot;
   *                                            is used, the message will be sent to all 16
   *                                            channels.
   * @param [time=undefined] {DOMHighResTimeStamp|String}   This value can be one of two things. If
   *                                      the value is a string starting with the + sign and
   *                                      followed by a number, the request will be delayed by the
   *                                      specified number (in milliseconds). Otherwise, the value
   *                                      is considered a timestamp and the request will be
   *                                      scheduled at that timestamp. The DOMHighResTimeStamp value
   *                                      is relative to the navigation start of the document. To
   *                                      retrieve the current time, you can use &#x60;WebMidi.time&#x60;. If
   *                                      &#x60;time&#x60; is not present or is set to a time in the past,
   *                                      the request is to be sent as soon as possible.
   *
   * @throws {Error}                      WebMidi must be enabled before sending messages.
   * @throws {RangeError}                 Controller numbers must be between 0 and 119.
   * @throws {RangeError}                 Value must be between 0 and 127.
   *
   * @return {WebMidi}                    Returns the &#x60;WebMidi&#x60; object so methods can be chained.
   */
  WebMidi.prototype.sendControlChange = function(controller, value, device, channel, time) {

    var that = this;

    if (!this.connected) { throw new Error(&quot;WebMidi must be connected before sending messages.&quot;); }

    controller = parseInt(controller);
    if (isNaN(controller) || controller &lt; 0 || controller &gt; 119) {
      throw new RangeError(&quot;Controller numbers must be between 0 and 119.&quot;);
    }

    value = parseInt(value);
    if (isNaN(value) || value &lt; 0 || value &gt; 127) {
      throw new RangeError(&quot;Value must be between 0 and 127&quot;);
    }

    this._convertChannelToArray(channel).forEach(function(ch) {
      that.send(
          (_channelMessages.controlchange &lt;&lt; 4) + (ch - 1),
          [controller, value],
          device,
          that._parseTimeParameter(time)
      );
    });

    return this;

  };

  /**
   * Sends a MIDI &#x60;channel mode&#x60; message to the specified device(s) and channel(s).
   *
   * @method sendChannelMode
   * @static
   * @chainable
   *
   * @param command {uint}                The MIDI channel mode command (120-127).
   * @param value {uint}                  The value to send (0-127)
   * @param [device=&quot;all] {String|Array}  The device id or an array of device ids. You can view
   *                                      available devices in the &#x60;WebMidi.outputs&#x60; array. The
   *                                      special value &quot;all&quot; can also be used.
   * @param [channel=&quot;all] {uint|Array|String}  The MIDI channel number (between 1 and 16) or an
   *                                            array of channel numbers. If the special value &quot;all&quot;
   *                                            is used, the message will be sent to all 16
   *                                            channels.
   * @param [time=undefined] {DOMHighResTimeStamp|String}   This value can be one of two things. If
   *                                      the value is a string starting with the + sign and
   *                                      followed by a number, the request will be delayed by the
   *                                      specified number (in milliseconds). Otherwise, the value
   *                                      is considered a timestamp and the request will be
   *                                      scheduled at that timestamp. The DOMHighResTimeStamp value
   *                                      is relative to the navigation start of the document. To
   *                                      retrieve the current time, you can use &#x60;WebMidi.time&#x60;. If
   *                                      &#x60;time&#x60; is not present or is set to a time in the past,
   *                                      the request is to be sent as soon as possible.
   *
   * @throws {Error}                      WebMidi must be enabled before sending messages.
   * @throws {RangeError}                 Channel mode controller numbers must be between 120 and
   *                                      127.
   * @throws {RangeError}                 Value must be between 0 and 127.
   *
   * @return {WebMidi}                    Returns the &#x60;WebMidi&#x60; object so methods can be chained.
   *
   */
  WebMidi.prototype.sendChannelMode = function(command, value, device, channel, time) {

    var that = this;

    if (!this.connected) { throw new Error(&quot;WebMidi must be connected before sending messages&quot;); }

    command = parseInt(command);
    if (isNaN(command) || command &lt; 120 || command &gt; 127) {
      throw new RangeError(&quot;Channel mode commands must be between 120 and 127.&quot;);
    }

    value = parseInt(value);
    if (isNaN(value) || value &lt; 0 || value &gt; 127) {
      throw new RangeError(&quot;Value must be integers between 0 and 127.&quot;);
    }

    this._convertChannelToArray(channel).forEach(function(ch) {

      that.send(
          (_channelMessages.channelmode &lt;&lt; 4) + (ch - 1),
          [command, value],
          device,
          that._parseTimeParameter(time)
      );

    });

    return this;

  };

  /**
   * Sends a MIDI &#x60;program change&#x60; message to the specified device(s) and channel(s).
   *
   * @method sendProgramChange
   * @static
   * @chainable
   *
   * @param program {uint}                The MIDI patch (program) number (0-127)
   * @param [device=&quot;all] {String|Array}  The device id or an array of device ids. You can view
   *                                      available devices in the &#x60;WebMidi.outputs&#x60; array. The
   *                                      special value &quot;all&quot; can also be used.
   * @param [channel=&quot;all] {uint|Array|String}  The MIDI channel number (between 1 and 16) or an
   *                                            array of channel numbers. If the special value &quot;all&quot;
   *                                            is used, the message will be sent to all 16
   *                                            channels.
   * @param [time=undefined] {DOMHighResTimeStamp|String}   This value can be one of two things. If
   *                                      the value is a string starting with the + sign and
   *                                      followed by a number, the request will be delayed by the
   *                                      specified number (in milliseconds). Otherwise, the value
   *                                      is considered a timestamp and the request will be
   *                                      scheduled at that timestamp. The DOMHighResTimeStamp value
   *                                      is relative to the navigation start of the document. To
   *                                      retrieve the current time, you can use &#x60;WebMidi.time&#x60;. If
   *                                      &#x60;time&#x60; is not present or is set to a time in the past,
   *                                      the request is to be sent as soon as possible.
   *
   * @throws {Error}                      WebMidi must be enabled before sending messages.
   * @throws {RangeError}                 Program numbers must be between 0 and 127.
   *
   * @return {WebMidi}                    Returns the &#x60;WebMidi&#x60; object so methods can be chained.
   *
   */
  WebMidi.prototype.sendProgramChange = function(program, device, channel, time) {

    var that = this;

    if (!this.connected) { throw new Error(&quot;WebMidi must be connected before sending messages.&quot;); }

    program = parseInt(program);
    if (isNaN(program) || program &lt; 0 || program &gt; 127) {
      throw new RangeError(&quot;Program numbers must be between 0 and 127.&quot;);
    }

    this._convertChannelToArray(channel).forEach(function(ch) {
      that.send(
          (_channelMessages.programchange &lt;&lt; 4) + (ch - 1),
          [program],
          device,
          that._parseTimeParameter(time)
      );
    });

    return this;

  };

  /**
   * Sends a MIDI &#x60;channel aftertouch&#x60; message to the specified device(s) and channel(s). For
   * key-specific aftertouch, you should instead use &#x60;sendKeyAftertouch()&#x60;.
   *
   * @method sendChannelAftertouch
   * @static
   * @chainable
   *
   * @param [pressure=0.5] {Number}       The pressure level (between 0 and 1). An invalid pressure
   *                                      value will silently trigger the default behaviour.
   * @param [device=&quot;all] {String|Array}  The device id or an array of device ids. You can view
   *                                      available devices in the &#x60;WebMidi.outputs&#x60; array. The
   *                                      special value &quot;all&quot; can also be used.
   * @param [channel=&quot;all] {uint|Array|String}  The MIDI channel number (between 1 and 16) or an
   *                                            array of channel numbers. If the special value &quot;all&quot;
   *                                            is used, the message will be sent to all 16
   *                                            channels.
   * @param [time=undefined] {DOMHighResTimeStamp|String}   This value can be one of two things. If
   *                                      the value is a string starting with the + sign and
   *                                      followed by a number, the request will be delayed by the
   *                                      specified number (in milliseconds). Otherwise, the value
   *                                      is considered a timestamp and the request will be
   *                                      scheduled at that timestamp. The DOMHighResTimeStamp value
   *                                      is relative to the navigation start of the document. To
   *                                      retrieve the current time, you can use &#x60;WebMidi.time&#x60;. If
   *                                      &#x60;time&#x60; is not present or is set to a time in the past,
   *                                      the request is to be sent as soon as possible.
   *
   * @throws {Error}                      WebMidi must be enabled before sending messages.
   *
   * @return {WebMidi}                    Returns the &#x60;WebMidi&#x60; object so methods can be chained.
   */
  WebMidi.prototype.sendChannelAftertouch = function(pressure, device, channel, time) {

    var that = this;

    if (!this.connected) { throw new Error(&quot;WebMidi must be connected before sending messages.&quot;); }

    pressure = parseFloat(pressure);
    if (isNaN(pressure) || pressure &lt; 0 || pressure &gt; 1) { pressure = 0.5; }

    var nPressure = Math.round(pressure * 127);

    this._convertChannelToArray(channel).forEach(function(ch) {
      that.send(
          (_channelMessages.channelaftertouch &lt;&lt; 4) + (ch - 1),
          [nPressure],
          device,
          that._parseTimeParameter(time)
      );
    });

    return this;

  };

  /**
   * Sends a MIDI &#x60;pitch bend&#x60; message to the specified device(s) and channel(s).
   *
   * @method sendPitchBend
   * @static
   * @chainable
   *
   * @param bend {Number}                   The intensity level of the bend (between -1 and 1). A
   *                                        value of zero means no bend.
   * @param [device=&quot;all] {String|Array}    The device id or an array of device ids. You can view
   *                                        available devices in the &#x60;WebMidi.outputs&#x60; array. The
   *                                        special value &quot;all&quot; can also be used.
   * @param [channel=&quot;all] {uint|Array|String}  The MIDI channel number (between 1 and 16) or an
   *                                            array of channel numbers. If the special value &quot;all&quot;
   *                                            is used, the message will be sent to all 16
   *                                            channels.
   * @param [time=undefined] {DOMHighResTimeStamp|String}   This value can be one of two things. If
   *                                      the value is a string starting with the + sign and
   *                                      followed by a number, the request will be delayed by the
   *                                      specified number (in milliseconds). Otherwise, the value
   *                                      is considered a timestamp and the request will be
   *                                      scheduled at that timestamp. The DOMHighResTimeStamp value
   *                                      is relative to the navigation start of the document. To
   *                                      retrieve the current time, you can use &#x60;WebMidi.time&#x60;. If
   *                                      &#x60;time&#x60; is not present or is set to a time in the past,
   *                                      the request is to be sent as soon as possible.
   *
   * @throws {Error}                      WebMidi must be enabled before sending messages.
   * @throws {RangeError}                 Pitch bend value must be between -1 and 1.
   *
   * @return {WebMidi}                    Returns the &#x60;WebMidi&#x60; object so methods can be chained.
   */
  WebMidi.prototype.sendPitchBend = function(bend, device, channel, time) {

    var that = this;

    if (!this.connected) { throw new Error(&quot;WebMidi must be connected before sending messages.&quot;); }

    bend = parseFloat(bend);
    if (isNaN(bend) || bend &lt; -1 || bend &gt; 1) {
      throw new RangeError(&quot;Pitch bend value must be between -1 and 1.&quot;);
    }

    var nLevel = Math.round((bend + 1) / 2 * 16383);
    var msb = (nLevel &gt;&gt; 7) &amp; 0x7F;
    var lsb = nLevel &amp; 0x7F;

    this._convertChannelToArray(channel).forEach(function(ch) {
      that.send(
          (_channelMessages.pitchbend &lt;&lt; 4) + (ch - 1),
          [lsb, msb],
          device,
          that._parseTimeParameter(time)
      );
    });

    return this;

  };

  /**
   * Returns a valid MIDI note number given the specified input. The input can be an integer
   * represented as a string, a note name (C3, F#4, D-2, G8, etc.), a float or an int between 0 and
   * 127.
   *
   * @param input         A integer, float or string to extract the note number from.
   * @throws {Error}      Invalid note number.
   * @returns {uint}      A valid MIDI note number (0-127).
   */
  WebMidi.prototype.guessNoteNumber = function(input) {

    var output = false;

    if (input &amp;&amp; input.toFixed &amp;&amp; input &gt;= 0 &amp;&amp; input &lt;= 127) {         // uint
      output = input;
    } else if (parseInt(input) &gt;= 0 &amp;&amp; parseInt(input) &lt;= 127) {        // uint as string
      output = parseInt(input);
    } else if (typeof input === &#x27;string&#x27; || input instanceof String) {  // string
      output = this.noteNameToNumber(input);
    }

    if (output === false) {
      throw new Error(&quot;Invalid note number (&quot; + input + &quot;).&quot;);
    } else {
      return output;
    }

  };

  /**
   * Returns a MIDI note number matching the note name passed in the form of a string parameter. The
   * note name must include the octave number which should be between -2 and 8: C5, G4, D#-1, F0,
   * etc.
   *
   * The lowest note is C-2 (MIDI note number 0) and the highest note is G8 (MIDI note number 127).
   *
   * @method noteNameToNumber
   * @static
   *
   * @param name {String}   The name of the note in the form of a letter, followed by an optional #
   *                        symbol, followed by the octave number (between -2 and 8).
   * @return {uint}         The MIDI note number (between 0 and 127)
   */
  WebMidi.prototype.noteNameToNumber = function(name) {

    var matches = name.match(/([CDEFGAB]#?)(-?\d+)/i);
    if(!matches) { throw new RangeError(&quot;Invalid note name.&quot;); }

    var number = _notes.indexOf(matches[1].toUpperCase());
    var octave = parseInt(matches[2]);
    var result = ((octave + 2) * 12) + number;

    if (number &lt; 0 || octave &lt; -2 || octave &gt; 8 || result &lt; 0 || result &gt; 127) {
      throw new RangeError(&quot;Invalid note name or note outside valid range.&quot;);
    }

    return result;

  };

  /**
   * Converts an input value (which can be an int, an array or the value &quot;all&quot; to an array of valid
   * MIDI note numbers.
   *
   * @method _convertNoteToArray
   * @param [channel] {uint|Array}
   * @private
   */
  WebMidi.prototype._convertNoteToArray = function(note) {

    var that = this,
        notes = [];

    if ( !Array.isArray(note) ) { note = [note]; }

    note.forEach(function(item) {
      notes.push(that.guessNoteNumber(item));
    });

    return notes;

  };

  /**
   * Converts an input value (which can be an int, an array or the value &quot;all&quot; to an array of valid
   * MIDI channels. If &quot;undefined&quot; is provided as the channel, an array of all channels will be
   * returned.
   *
   * @method _convertChannelToArray
   * @param [channel] {uint|Array}
   * @private
   */
  WebMidi.prototype._convertChannelToArray = function(channel) {

    if (channel === &#x27;all&#x27; || channel === undefined) { channel = [&#x27;all&#x27;]; }

    if ( !Array.isArray(channel) ) { channel = [channel]; }

    if (channel.indexOf(&#x27;all&#x27;) &gt; -1) {
      channel = [];
      for (var i = 1; i &lt;= 16; i++) { channel.push(i); }
    }

    channel.forEach(function(ch) {
      if ( !(ch &gt;= 1 &amp;&amp; ch &lt;= 16) ) {
        throw new RangeError(&quot;MIDI channels must be between 1 and 16.&quot;);
      }
    });

    return channel;

  };

  /**
   *
   * @method _parseTimeParameter
   * @param [time=0] {Number|String}
   * @private
   */
  WebMidi.prototype._parseTimeParameter = function(time) {

    if (time &amp;&amp; time.substring &amp;&amp; time.substring(0, 1) === &quot;+&quot;) {
      return (parseFloat(time) + this.time) || undefined;
    } else {
      return parseFloat(time) || undefined;
    }

  };

  // Check if RequireJS/AMD is used. If it is, use it to define our module instead of
  // polluting the global space.
  if ( typeof define === &quot;function&quot; &amp;&amp; typeof define.amd === &quot;object&quot;) {
    define([], function () {
      return new WebMidi();
    });
  } else if (typeof module !== &quot;undefined&quot; &amp;&amp; module.exports) {
    module.exports = WebMidi;
  } else {
    if (!scope.WebMidi) { scope.WebMidi = new WebMidi(); }
  }

}(this));

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
